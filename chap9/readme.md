

> 每个进程都有自己的页表-内核通过为每个进程提供自己独立的页表来实现这一点，在进程的上下文中，它是内核中的数据结构，是内核为进程所维护的，每个进程的页表都映射该进程的虚拟地址空间

> 由于时间局部性和空间局部性原理，你往往会重复使用相同的东西或者使用附件的东西

* 每个虚拟页面都可以映射到任何物理页面，这样可以真正帮助简化操作，甚至在不同时刻，相同的虚拟页面也可以存储在不同的物理页面中

* 可以将多个虚拟页面映射到同一物理页面，这是一种使多个进程可以共享某些代码或数据的非常简单直接的方式，只需让这些不同进程中的页表条目指向相同的物理页面即可，这就是共享库的实现方式，所以lib.c对于系统上运行的每个进程来说都是相同的代码，所以libc只需要加载到物理内存中一次，然后想要访问lib.c中的函数和数据的进程只需要映射，让虚拟地址空间中的页面指向实际加载lib.c的物理页面，现在系统中只有一个lib.c的副本但每个过程都可以认为它有自己的副本。

* 使用虚拟内存来帮助简化内存管理，可以大大简化链接和加载，链接器现在可以假设每个程序都将加载到完全相同的位置(0x400000)，所以链接器能提前知道这些东西将要加载到哪里，然后它可以相应地重定位所有这些引用。

* 如果要加载程序，execve会查看elf二进制文件，也就是可执行二进制文件，它可以知道二进制文件中的代码和数据段有多大

* X86理论上地址是64位，但实际上虚拟内存只用了48位地址，
剩下最高位的是为内核保留的，为内核代码和内核数据保留

### 9.7.2 

### 9.8.1 再看共享对象
* 进程这一抽象能够为每个进程提供自己私有的虚拟地址空间，可以免受其他进程的错误读写。

## 9.9 动态内存分配
* malloc 返回的字节大小在x86上是8字节对齐，在x86-64上是16字节对齐
* 所以一旦我们得到了指针，我们就可以像对待数组一样对待它，所以我么可以通过循环来初始化它
* 在c语言中中malloc为程序分配了一个块，分配器就无法再触碰它
* 块必须对齐，如果它们是16字节对齐的，那么块必须以16字节边界开始，如果你要请求2字节的有效载荷，你有很多浪费的字节，这会降低利用率

### 9.9.3 分配器的要求和目标
* 目标2：**最大化内存利用率**。实际上，一个系统中被所有进程分配的虚拟内存的全部数量是受磁盘上交换空间的数量限制的。

### 9.9.4
* 因为外部碎片难以量化且不可能预测，所以分配器通常采用启发式策略来试图维持少量的大空闲块，而不是维持大量的小空闲块。

