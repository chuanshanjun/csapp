# Chapter 8

### defination ECF
现代系统通过使控制流发生突变来对这些情况做出反应。一般而言，我们把这些突变称为**异常控制流(Exceptional Control Flow, ECF)**。异常控制流发生在计算机系统的各个层次。比如，在硬件检测到的事件会触发控制突然转移到异常处理程序。在操作系统层，内核通过上下文切换将控制从一个用户进程转移到另一个用户进程。在应用层，一个进程可以发送**信号**到另一个进程，而接收者会控制突然转移到它的一个信号处理程序。一个程序可以通过回避通常的栈规则，并执行到其他函数中的任意位置的非本地跳转来对错误做出反应。--p501

## 8.1 异常
异常是异常控制流的一种形式，它一部分由硬件实现，一部分由操作系统实现。
在任何情况下，当处理器检测到有事件发生时，它就会通过一张叫**异常表(exception table)**的跳转表，进行一个间接过程调用（异常），到一个专门设计用来处理这类事件的操作系统子程序（异常处理程序(exception handler)）。--p502  
异常表的起始地址放在一个叫做**异常表基址寄存器(exception table base register)**的特殊CPU寄存器里。--p503

### 8.1.2 异常类别
* 中断: 中断是异步的，是来自处理器外部的I/O设备的信号的结果。硬件中断不是由任何一条专门的指令造成的，从这个意义上来说它是异步的。硬件中断的异常处理程序常常称为**中断处理程序(interrupt handler)** --p504
* 陷阱和系统调用: 陷阱是有意的异常，是执行一条指令的结果。就像中断处理程序一样，陷阱处理程序将控制返回到下一条指令。陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，叫做**系统调用**。从程序员的角度来看，系统调用和普通的函数调用是一样的。然而，它们的实现非常不同。普通的函数运行在**用户模式**中，用户模式限制了函数可以执行的指令类型，而且它们只能访问与调用函数相同的栈。系统调用运行在**内核模式**中，内核模式允许系统调用执行特权指令，并访问定义在内核中的栈。--p505
* 故障：故障由错误情况引起，它可能能够被故障处理程序修正。故障处理-根据故障是否能够被修复，故障处理程序要么重新执行引起故障的指令，要么终止。--p505
* 终止：终止是不可恢复的致命错误造成的结果，通常是一些硬件错误，比如DRAM或者SRAM位被损坏时发生的奇偶错误。

### 8.1.3 Linux/x86-64 系统中的异常
* 一般保护故障。许多原因都会导致不为人知的一般保护故障（异常13），通常是因为一个程序引用了一个未定义的虚拟内存区域，或者因为程序试图写一个只读的文本段。Linux不会尝试恢复这类故障。Linux shell通常会把这种一般保护故障报告为“段故障(Segmentation fault)” --p506
* C程序用syscall函数可以直接调用任何系统调用。然而，实际中几乎没必要这么做。对于大多数系统调用，标注呢C库提供了一组方便的包装函数。这些包装函数将参数打包到一起，以适当的系统调用指令陷入内核，然后将系统调用的返回状态传递回调用函数。所有到Linux系统调用的参数都是通过通用寄存器而不是栈传递的。--p506
* 按照惯例，寄存器%rax包含系统调用号，寄存器%rdi,%rsi,%rdx,%r10,%r8和%r9包含最多6个参数。第一个参数在%rdi中，第二个在%rsi中，以此类推。从系统调用返回时，寄存器%rcx和%r11都会被破坏，%rax包含返回值。-4095到-1之间的负数返回值表明发生了错误，对应于负的errno。 --p507

```C
int main() {
    write(1, "hello, world\n", 13);
    _exit(0);
}
```

* write函数的第一个参数将输出发送到stdout。第二个参数是要写的字节序列，而第三个参数是要写的字节数。 --p507