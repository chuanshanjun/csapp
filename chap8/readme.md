# Chapter 8

### defination ECF
现代系统通过使控制流发生突变来对这些情况做出反应。一般而言，我们把这些突变称为**异常控制流(Exceptional Control Flow, ECF)**。异常控制流发生在计算机系统的各个层次。比如，在硬件检测到的事件会触发控制突然转移到异常处理程序。在操作系统层，内核通过上下文切换将控制从一个用户进程转移到另一个用户进程。在应用层，一个进程可以发送**信号**到另一个进程，而接收者会控制突然转移到它的一个信号处理程序。一个程序可以通过回避通常的栈规则，并执行到其他函数中的任意位置的非本地跳转来对错误做出反应。--p501

## 8.1 异常
异常是异常控制流的一种形式，它一部分由硬件实现，一部分由操作系统实现。
在任何情况下，当处理器检测到有事件发生时，它就会通过一张叫**异常表(exception table)**的跳转表，进行一个间接过程调用（异常），到一个专门设计用来处理这类事件的操作系统子程序（异常处理程序(exception handler)）。--p502  
异常表的起始地址放在一个叫做**异常表基址寄存器(exception table base register)**的特殊CPU寄存器里。--p503

### 8.1.2 异常类别
* 中断: 中断是异步的，是来自处理器外部的I/O设备的信号的结果。硬件中断不是由任何一条专门的指令造成的，从这个意义上来说它是异步的。硬件中断的异常处理程序常常称为**中断处理程序(interrupt handler)** --p504
* 陷阱和系统调用: 陷阱是有意的异常，是执行一条指令的结果。就像中断处理程序一样，陷阱处理程序将控制返回到下一条指令。陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，叫做**系统调用**。从程序员的角度来看，系统调用和普通的函数调用是一样的。然而，它们的实现非常不同。普通的函数运行在**用户模式**中，用户模式限制了函数可以执行的指令类型，而且它们只能访问与调用函数相同的栈。系统调用运行在**内核模式**中，内核模式允许系统调用执行特权指令，并访问定义在内核中的栈。--p505
* 故障：故障由错误情况引起，它可能能够被故障处理程序修正。故障处理-根据故障是否能够被修复，故障处理程序要么重新执行引起故障的指令，要么终止。--p505
* 终止：终止是不可恢复的致命错误造成的结果，通常是一些硬件错误，比如DRAM或者SRAM位被损坏时发生的奇偶错误。

### 8.1.3 Linux/x86-64 系统中的异常
* 一般保护故障。许多原因都会导致不为人知的一般保护故障（异常13），通常是因为一个程序引用了一个未定义的虚拟内存区域，或者因为程序试图写一个只读的文本段。Linux不会尝试恢复这类故障。Linux shell通常会把这种一般保护故障报告为“段故障(Segmentation fault)” --p506
* C程序用syscall函数可以直接调用任何系统调用。然而，实际中几乎没必要这么做。对于大多数系统调用，标准C库提供了一组方便的包装函数。这些包装函数将参数打包到一起，以适当的系统调用指令陷入内核，然后将系统调用的返回状态传递回调用函数。所有到Linux系统调用的参数都是通过通用寄存器而不是栈传递的。--p506
* 按照惯例，寄存器%rax包含系统调用号，寄存器%rdi,%rsi,%rdx,%r10,%r8和%r9包含最多6个参数。第一个参数在%rdi中，第二个在%rsi中，以此类推。从系统调用返回时，寄存器%rcx和%r11都会被破坏，%rax包含返回值。-4095到-1之间的负数返回值表明发生了错误，对应于负的errno。 --p507

```C
int main() {
    write(1, "hello, world\n", 13);
    _exit(0);
}
```

* write函数的第一个参数将输出发送到stdout。第二个参数是要写的字节序列，而第三个参数是要写的字节数。 --p507

## 8.2 进程
* 进程的经典定义就是**一个执行中程序的实例**。系统中的每个程序都运行在某个进程的**上下文(context)**中。上下文是由程序正确运行所需的状态组成的。这个状态包括放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。  
每次用户通过向shell输入一个可执行目标文件的名字，运行程序时，shell就会创建一个新的进程，然后在这个新进程的上下文中运行它们自己的代码或其他应用程序。  
进程提供应用程序的关键抽象：
     * 一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占地使用处理器。
     * 一个私有的地址空间，它提供一个假象，好像我们的程序独占地使用内存系统。
--p509

* 一个逻辑流的执行在时间上与另一个流重叠，称为**并发流(concurrent flow)**，这两个流被称为并发地运行。  
多个流并发地执行的一般现象被称为**并发(concurrency)**。一个进程和其他进程轮流运行的概念称为**多任务(multitasking)**。一个进程执行它的控制流的一部分的每一时间段叫做**时间片(time slice)**。因此多任务也叫做**时间分片(time slicing)**。  
如果两个流在时间上重叠，那么它们就是并发的，即使它们运行在同一个处理器上。不过，有时我们会发现确认并行流是很有帮助的，它是并发流的一个真子集。如果两个流并发地运行在不同的处理器或者计算机上，那么我们称他们为**并行流(parallel flow)**，他们并行地运行(running in parallel)，且并行地执行(parallel execution)。-- p509

### 8.2.3 私有地址空间
* 尽管和每个私有地址空间相关联的内存的内容一般是不同的，但是每个这样的空间都有相同的通用结构。  
地址空间底部是保留给用户程序的，包括通常的代码、数据、堆和栈段。代码段总是从地址0x400000开始。地址空间顶部保留给内核（操作系统常驻内存的部分）。地址空间的这个部分包含内存在代表进程执行指令时（比如当应用程序执行系统调用时）使用的代码、数据、栈。--p510

### 8.2.4 用户模式和内核模式
* 处理器通常是用某个控制寄存器中的一个模式为基位(mode bit)来提供这种功能的，该寄存器描述了进程当前想有的特权。当设置了模式位时，进程就运行在**内核模式**中（有时叫做**超级用户模式**）。一个运行在内核模式的进程可以执行指令集中的任何指令，并且可以访问系统中的任何内存内置。  
没有设置模式位时，进程就运行在**运行模式中。**用户模式中的进程不允许执行**特权指令(privileged instruction)**，比如停止处理器、改变模式位，或者发起一个I/O操作。也不允许用户模式中的进程直接引用地址空间中内核区的代码和数据。任何这样的尝试都会导致致命的保护故障。反之，用户程序必须痛殴系统调用接口间接地访问内核代码和数据。--p510  
运行应用成代码的进程初始时是在用户模式中。进程从用户模式变为内核模式的唯一方法是通过诸如中断、故障或者陷入系统调用这样的异常。当异常发生时，控制传递到异常处理程序，处理器将模式从用户模式变为内核模式。处理程序运行在内核模式中，当它返回到应用程序代码时，处理器就把模式从内核模式改回到用户模式。  

### 8.2.5 上下文切换
* 操作系统内核使用一种称为**上下文切换(context switch)**的较高层形式的异常控制流来实现多任务。  
内核为每个进程维持一个**上下文(context)**。上下文就是内核重新启动一个被抢占的进程所需的状态。它由一些对象的值组成，这些对象包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构，比如描述地址空间的页表、包含有关当前进程信息的**进程表**，以及包含进程已打开文件的信息的**文件表**。
* 在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程。这种决策叫做**调度(scheduling)**，是由内核中称为**调度器(scheduler)**的代码处理的。当内核选择一个新的进程运行时，我们说内核**调度了**这个进程。在内核调度了一个新的进程运行后，它就抢占当前进程，并使用一种称为**上下文切换**的机制来控制转移到新的进程，**上下文切换**1）保存当前进程的上下文，2）恢复某个先前被抢占的进程被保存的上下文，3）将控制传递给这个新恢复的进程。
* 当内核代表用户执行系统调用时，可能会发生上下文切换。如果系统调用因为等待某个事件发生而阻塞，那么内核可以让当前进程休眠，切换到另一个进程。比如，如果一个read系统调用需要访问磁盘，内核可以选择执行上下文切换，运行另外一个进程，而不是等待数据从磁盘到达。另一个示例示sleep系统调用，它显示地请求调用进程休眠。一般而言，即使系统调用没有阻塞，内核也可以决定执行上下文切换，而不是将控制返回给调用进程。
* 中断也可能引发上下文切换。比如，所有的系统都有某种产生周期性定时器中断的机制，通常为每1毫秒或每10毫秒。每次发生定时器中断时，内核就能判定当前进程已经运行了足够长的时间，并切换到一个新的进程。--p511

## 8.3 系统调用错误处理
> eg: 下面是我们调用 Unix fork 函数时会如何检查错误：
```C
if ((pid = fork()) < 0) {
    fprintf(stderr, "fork error: %s\n", strerror(errno));
    exit(0);
}
```

> eg: 错误包装函数

```C
void unix_error(char *msg) { /* Unix-style error */
    fprintf(stderr, "%s: %s\n", msg, strerror(errno));
    exit(0);
}
```

> eg: 使用错误包装函数 可以使代码更简洁

```C
if ((pid = fork()) < 0)
    unix_error("fork error");
```

```C
pid_t Fork() { // fork() 包装函数 Fork()
    pid_t pid;

    if ((pid = fork()) < 0) {
        unix_error("Fork error");
    }
    return pid;
}
```

## 8.4 进程控制
### 8.4.1 获取进程ID
* 每个进程都有一个唯一的正数（非零）进程ID(PID)。getpid函数返回调用进程的PID。getppid函数返回它的父进程的PID（创建调用进程的进程）。  
* getpid和getppid函数返回一个类型为pid_t的整数值，在Linux系统上它在types.h中被定义为int。
```C
#include <sys/types.h>
#include <unistd.h>

pid_t getpid(void);
pid_t getppid(void);
```

### 8.4.2 创建和终止进程
从程序猿的角度，我们可以认为进程总是处于下面三种状态之一：
* 运行。进程要么在CPU上执行，要么在等待被执行且最终会被内核调度。
* 停止。进程的执行被**挂起(suspended)**，且不会被调度。当收到SIGSTOP、SIGT-STP、SIGTIN或者SIGTTOU信号时，进程就停止，并且保持停止直到它收到一个SIGCONT信号，在这个时刻，进程再次开始运行。（**信号**是一种软件中断的形式）
* 终止。进程永远地停止了。进程会因为三种原因终止：1）收到一个信号，该信号的默认行为是终止进程，2）从主程序返回，3）调用exit函数。
```C
#include <stdlin.h>

void exit(int status);
```
* exit函数以status**退出状态**来终止进程（另一种设置退出状态的方式是从主程序中返回一个整数值）。
* **父进程**通过调用fork函数创建一个新的运行的**子进程**。
```C
#include <sys/types.h>
#include <unistd.h>

pid_t fork(void);
```

* 新创建的子进程几乎但不完全与父进程相同。子进程得到与父进程用户级虚拟地址空间相同的（但是独立的）一份副本，包括代码和数据段、堆、共享库以及用户栈。子进程还获得与父进程任何打开文件描述符相同的副本，这就意味着当父进程调用fork时，子进程还获得与父进程任何打开文件描述符相同的副本，这就意味着当父进程调用fork时，子进程可以读写父进程中打开的任何文件。父进程和新创建的子进程之间最大的区别在于它们有不同的PID。
* fork函数是有趣的（也常常令人迷惑），因为它只被调用一次，却会返回两次：一次是在调用进程（父进程）中，一次是在新创建的子进程中。在父进程中，fork返回子进程的PID。在子进程中，fork返回0。因为子进程的PID总是为非零，返回值就提供一个明确的方法来分辨程序是在父进程还是在子进程中执行。
```C
int main() {
    pid_t pid;
    int x = 1;

    pid = Fork();
    if (pid == 0) { // Child
        printf("child: x=%d\n", ++x);
        exit(0);
    }

    // Parent
    printf("parent: x=%d\n", --x);
    exit(0);
}
```

* 调用一次，返回两次
* 并发执行：作为程序员，我们绝不能对不同进程中指令的交替执行做任何假设。
* 相同但是独立的地址空间
* 共享文件

### 8.4.3 回收子进程
* 当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除。相反，进程被保持在一种已终止的状态中，直到被它的父进程**回收(reaped)**。当父进程回收已终止的子进程时，内核将子进程的退出状态传递给父进程，然后抛弃已终止的进程，从此开始，该进程就不存在了。一个终止了但还未被回收的进程称为**僵死进程(zombie)**。
* 如果一个父进程终止了，内核会安排init进程成为它的孤儿进程的养父。init进程的PID为1，是在系统启动时由内核创建的，它不会终止，是所有进程的祖先。如果父进程没有回收它的僵死子进程就终止了，那么内核会安排init进程去回收它们。不过，长时间运行的程序，比如shell或者服务器，总是应该回收它们的僵死子进程。即使僵死子进程没有运行，它们仍然消耗系统的内存资源。
* 一个进程可以通过调用waitpid函数来等待它的子进程终止或者停止。
```C
#include <sys/types.h>
#include <sys/wait.h>

pid_t waitpid(pid_t pid, int *statusp, int options);

返回：如果成功，则为子进程的PID，如果WNOHANG，则为0，如果其他错误，则为-1。
```
* waitpid函数有点复杂。默认情况下(当options=0时)，waitpid挂起调用进程的执行，直到它的**等待集合(wait set)**中的一个子进程终止。如果等待集合中的一个进程在刚调用的时刻就已经终止了，那么waitpid就立即返回。在这两种情况中，waitpid返回导致waitpid返回的已终止子进程的PID。此时，已终止的子进程已经被回收，内核会从系统中删除掉它的所有痕迹。--p516

> man waitpid defination: All  of  these  system  calls are used to wait for state changes in a child of the calling process, and obtain information about the child whose state has changed. 

* the child terminated
* the child was stopped by a signal

**1. 判定等待集合的成员**
等待集合的成员由参数pid来确定的：
* 如果pid>0，那么等待集合就是一个单独的子进程，它的进程ID等于pid。
* 如果pid=-1，那么等待集合就由父进程所有的子进程组成的。

**2. 修改默认行为**  
可以通过将option设置为常量WNOHANG、WUNTRACED和WCONTINUED的各种组合来修改默认行为：
* WNOHANG(W NO HANG，即不阻塞模式):如果等待集合中的任何子进程都还没有终止，那么就立即返回（返回值为0）。默认的行为是挂起调用进程，直到有子进程终止。在等待子进程终止的同时，如果还想做些有用的工作，这个选项会有用。
* WUNTRACED:挂起调用进程的执行，直到等待集合中的一个进程变成已终止或者被停止。返回的PID为导致返回的已终止或被停止子进程的PID。默认的行为是只返回已终止的子进程。当你想要检查已终止和被停止的子进程时，这个选项会有用。
* WCONTINUED: 挂起调用进程的执行，直到等待集合中一个正在运行的进程终止或等待集合中一个被停止的进程收到SIGCONT信号重新开始执行。  
> 可以用或运算把这些选项组合起来。例如：
* WNOHANG | WUNTRACED: 立即返回，如果等待集合中的子进程都没有被停止或终止，则返回值为0;如果有一个停止或终止，则返回值为该子进程的PID。

**3. 检查已回收子进程的退出状态**
如果statusp参数是非空的，那么waitpid就会在status中放上关于导致返回的子进程的状态信息，status是statusp指向的值。wait.h头文件定义了解释status参数的几个宏：
* WIFEXITED(status):如果子进程通过调用exit或者一个返回(return)正常终止，就返回真。
* WEXITSTATUS(status):返回一个正常终止的子进程的退出状态。只有在WIFEXITED()返回为真时，才会定义这个状态。
* WIFSIGNALED(status):如果子进程是因为一个未被捕获的信号终止的，那么就返回真。
* WTERMSIG(status):返回导致子进程终止的信号的编号。只有在WIFSIGNALED()返回为真时，才定义这个状态。
* WIFSTOPPED(status):如果引起返回的子进程当前是停止的，那么就返回真。
* WSTOPSIG(status):返回引起子进程停止的信号的编号。只有在WIFSTOPPED()返回为真时，才定义这个状态。
* WIFCONTINUED(status):如果子进程收到SIGCONT信号重新启动，则返回真。

**4. 错误条件**
如果调用进程没有子进程，那么waitpid返回-1，并且设置errno为ECHILD。如果waitpid函数被一个信号中断，那么它返回-1，并设置errno为EINTR。

**5. wait函数**
wait函数是waitpid函数的简单版本：
```C
#include <sys/types.h>
#include <sys/wait.h>

pid_t wait(int *statusp);

返回:如果成功，则为子进程的PID，如果出错，则为-1
```  

* 调用wait(&status)等价于waitpid(-1, &status, 0);  

* 当回收了所有的子进程之后，再调用waitpid就返回-1,并且设置errno为ECHILD。

* 注意，程序不会按照特定的顺序回收子进程。子进程回收的顺序是这台特定的计算机系统的属性。在另一个系统上，甚至在同一个系统上再次执行一次，两个字进程都可能以相反的顺序被回收。这是**非确定性**行为的一个示例，这种非确定性行为使得对并发进行推理非常困难。两种可能的结果都同样是正确的，作为一个程序员，你绝对不可以假设总是会出现某一个结果，无论多么不可能出现另一个结果。唯一正确的假设是每一个可能的结果同样可能出现。

### 8.4.4 让进程休眠
sleep函数将一个进程挂起一段指定的时间  
如果请求的时间量已经到了，sleep返回0，否则返回还剩下的要休眠的秒数。
```C
#include <unistd.h>

unsigned int sleep(unsigned int secs);
```

pause函数，该函数让调用函数休眠，直到该进程收到一个信号。
```C
#include <unistd.h>

int pause(void);
```

### 8.4.5 加载并运行程序
execve函数在当前进程的上下文中加载并运行一个新程序。
```C
#include <unistd.h>

int execve(const char *filename, const char *argv[],
            const char *envp[]);
```

* execve函数加载并运行可执行目标文件filename, 且带参数列表argv和环境变量列表envp。只有当出现错误时，例如找不到filename,execve才会返回到调用程序。所以，与fork一次调用返回两次不同，execve调用一次并从不返回。--p521
* argv变量指向一个以null结尾的指针数组，其中每个指针都指向一个参数字符串。按照惯例，argv[0]是可执行目标文件的名字。环境变量的列表是由一个类似的数据结构表示的。envp变量指向一个以null结尾的指针数组，其中每个指针指向一个环境变量字符串，每个串都是形如"name=value"的名字-值对。--p521
* 在execve加载了filename之后，它调用7.9节中描述的启动代码。启动代码设置栈，并将控制传递给新程序的主函数，该函数有如下形式的原型
```C
int main(int argc, char **argv, char **envp);
或等价的
int main(int argc, char *argv[], char *envp[]);
```

**程序与进程的区别**
* 程序是一堆代码和数据；程序可以作为目标文件存在于磁盘上，或者作为段存在于地址空间中。进程是执行中程序的一个具体实例；程序总是存在某个进程的上下文中。
* fork函数在新的子进程中运行相同的程序，新的子进程是父进程的一个复制品。execve函数在当前进程的上下文中加载并运行一个新的程序。它会覆盖当前进程的地址空间，但并没有创建一个新的进程。新的程序仍然有相同的PID，并且继承了调用execve函数时已打开的所有文件描述符。

### 8.4.6 利用fork和execve运行程序
