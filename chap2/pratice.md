### p2.8
a = 01101001
b = 01010101

~a = 10010110
~b = 10101010

a&b = 01000001
a|b = 01111101
a^b = 00111100
### p2.9
000 -> 111
001 -> 110
011 -> 100
100 -> 011
101 -> 010
110 -> 001
111 -> 000

蓝色 | 绿色  
001 | 010 -> 011  
黄色 & 蓝绿色  
110 & 011 -> 0101  
红色 ^ 红紫色  
100 ^ 101 -> 001

### p2.10
```c
void inplace(int *x, int *y) {
    *y = *x ^ *y;
    *x = *x ^ *y;
    *y = *x ^ *y;
}
```

初始值 *x = a, *y = b;
第一步 *x = a, *y = a^b;
第二部 *x = a^(a^b) = b, *y = a^b;
第三步 *y = b^(a^b) = a, *x =b;

### p2.11
A  first = last = array[k];  
B *y = *x ^ *y -> a ^ a = 0;
*y = 0; 
因为*a也指向同一个地址,此时值被修改,则 *a = 0;  
C first <= last -> first < last;

### p2.12
```c
// p2.12
int x;
x = 0x87654321;

// x的最低有效字节,其余位置均置为0 [0x00000021]
show_int(x&0xFF);

// 除了x的最低有效字节外,其他的位都取补, 最低有效字节保持不变 [0x789ABC21]
show_int((~x)^0xFF);

// x的最低有效字节设置成全1,其他字节保持不变 [0x876543FF]
show_int(x|0xFF);
```

### p2.13
```c
int bis(int x, int m);
int bic(int x, int m);

// 实现 x|y
int bool_or(int x, int y) {
    int result = bis(x, y);
    return result;
}

// 实现 x^y
int bool_xor(int x, int y) {
    int result = bis(bic(x, y), bic(y, x));
    return result;
}
```

### p2.14
x = 0x66, y = 0x39  
x&y = 0x20  
x|y = 0x7F  
~x | ~y = 0xDF  
x & !y = 0  
x && y = 0x01
x || y = 0x01
!x||!y = 0x00
x && ~y = 0x01

### p2.15
只是用位级和逻辑运算，编写一个C表达式，它等价于 x==y。换句话说，当x和y相等时它将返回1，否则返回0。  
表达式: !(x^y)

### p2.16
x = 0xC3 1100 0011   
x << 3 -> 0001 1000 0x18  
x >> 2(逻辑) -> 0011 0000 0x30  
x >> 2(算数) -> 1111 0000 0xF0  

x = 0x75 0111 0101  
x << 3 -> 1010 1000 0xA8  
x >> 2(逻辑) -> 0001 1101 0x1D  
x >> 2(算数) -> 0001 1101 0x1D  

x = 0x87 1000 0111  
x << 3 -> 0011 1000 0x38  
x >> 2(逻辑) -> 0010 0001 0x21  
x >> 2(算数) 1110 0001 0xE1  

x = 0x66 0110 0110  
x << 3 -> 0011 0000 0x30  
x >> 2(逻辑) 0001 1001 0x19  
x >> 2(算数) 0001 1001 0x19


