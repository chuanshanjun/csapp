# chap3
## 3.2
### 3.2.2 代码示例
* 链接器的任务之一就是为函数调用找到匹配的函数的可执行代码的位置。 --p117  
* 插入这些指令(nop)是为了使函数代码变为16字节，使得就存储系统性能而言，能更好地放置下一个代码块。  --p117
* 所有'.'开头的行都是指导汇编器和链接器工作的伪指令。我们通常可以忽略这些行。另一方面，也没有关于指令的用途以及它们与源代码之间关系的解释说明。 --p117  
## 3.4
* 一个x86-64的中央处理单元(CPU)包含一组16个存储64位值的**通用目的寄存器**。 --p119
* 在后面的章节中，我们会展现很多指令，复制和生成1字节、2字节、4字节和8字节值。当这些指令以寄存器作为目标时，对于生成小于8字节结果的指令，寄存器中剩下的字节会这么样，对此有两条规则：生成1字节和2字节数字的指令会保持剩下的字节变；生成4字节数字的指令会把高4个字节置为0。后面这条规则是作位从IA32到x86-64的扩展的一部分而采用的。 --p120
### 3.4.2
* x86-64加了一条限制，传送指令的两个操作数不能都指向内存位置。将一个值从一个内存位置复制到另一个内存位置需要两条指令——第一条指令将源值加载到寄存器中，第二条将该寄存器值写入目的位置。 --p121
* 大多数情况中,MOV指令只会更新目的操作数指定的那些寄存器字节或内存位置。唯一的例外是movl指令以寄存器作为目的时，它会把该寄存器的高4位字节设置位0。造成这个例外的原因是x86-64采用的惯例，即任何为寄存器生成32位值的指令都会把该寄存器的高位部分置成0。 --p123
* 常规的movq指令只能以表示为32位补码数字的立即数作为源操作数，然后把这个值符号扩展到64位的值，放到目的位置。movabsq指令能够以任意64位立即数值作为源操作数，并且只能以寄存器作为目的地。 --p123
* 练习题3.2 x86-64中的内存引用总是用四字长寄存器给出，例如%rax，哪怕操作数只是一个字节、一个字或是一个双字。 --p226
* 首先，我们看到C语言中所谓的“指针”其实就是地址。间接引用指针就是将该指针放在一个寄存器中，然后在内存引用中使用这个寄存器。其次，像x这样的局部变量通常是保存在寄存器中，而不是内存中。访问寄存器比访问内存要快得多。 --p125
* 练习题3.4 当执行强制类型转换既涉及大小变化又涉及C语言中符号变化时，操作应该先改变大小(2.2.6节)
    * 2.2.6 
        * 无符号数的**零扩展（zero extension）**：要将一个无符号数转换为一个更大的数据类型，我们只要简单地在表示开头添加0。
        * 补码数的符号扩展：要将一个补码数字转换为一个更大的数据类型，可以执行一个**符号扩展（sign extension）**，在表示中添加最高有效位的值。
### 3.4.4
* 栈可以实现为一个数组，总是从数组的一端插入和删除元素。这一端被称为**栈顶**。栈向下增长，这样一来，栈顶元素的地址是所有栈中元素地址中最低的。（根据惯例，我们的栈是倒过来画的，栈“顶”在图的底部。）栈指针%rsp保存着栈顶元素的地址。 --p127
* tips:栈寄存器%rsp，其实存放的就是栈顶的地址。 --p128
* 图3-9 牢记 --p128
# 2.5
* **加载有效地址(load effective address)**指令leaq实际上是movq指令的变形。它的指令形式是从内存读数据到寄存器，但实际上它根本就没有引用内存。它的第一个操作数看上去是一个内存引用，但该指令并不是从指定的位置读入数据，而是将有效地址写入到目的操作数。这条指令可以为后面的内存引用产生指针。另外，它还可以简洁地描述普通的算术操作。
* 只有leaq没有其他大小的变种，如ADD由四条加法指令组成：addb、addw、addl和addq
### 3.5.2 一元和二元操作
* 指令incq(%rsp)会使栈顶的**8字节元素加1**。C语言中（++、--操作）。
* 二元操作，第二个操作数即是源又是目的。C语言中的赋值运算符，例如x-=y。例如，指令subq %rax, %rdx使寄存器%rdx的值减去%rax中的值。（将指令解读成“从%rdx中减去%rax”会有所帮助。）注意，当第二个操作数为内存地址时，处理器必须从内存读出值，执行操作，再把结果写回内存。