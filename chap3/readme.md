# chap3
## 3.2
### 3.2.2 代码示例
* 链接器的任务之一就是为函数调用找到匹配的函数的可执行代码的位置。 --p117  
* 插入这些指令(nop)是为了使函数代码变为16字节，使得就存储系统性能而言，能更好地放置下一个代码块。  --p117
* 所有'.'开头的行都是指导汇编器和链接器工作的伪指令。我们通常可以忽略这些行。另一方面，也没有关于指令的用途以及它们与源代码之间关系的解释说明。 --p117  
## 3.4
* 一个x86-64的中央处理单元(CPU)包含一组16个存储64位值的**通用目的寄存器**。 --p119
* 在后面的章节中，我们会展现很多指令，复制和生成1字节、2字节、4字节和8字节值。当这些指令以寄存器作为目标时，对于生成小于8字节结果的指令，寄存器中剩下的字节会这么样，对此有两条规则：生成1字节和2字节数字的指令会保持剩下的字节变；生成4字节数字的指令会把高4个字节置为0。后面这条规则是作位从IA32到x86-64的扩展的一部分而采用的。 --p120
### 3.4.2
* x86-64加了一条限制，传送指令的两个操作数不能都指向内存位置。将一个值从一个内存位置复制到另一个内存位置需要两条指令——第一条指令将源值加载到寄存器中，第二条将该寄存器值写入目的位置。 --p121
* 大多数情况中,MOV指令只会更新目的操作数指定的那些寄存器字节或内存位置。唯一的例外是movl指令以寄存器作为目的时，它会把该寄存器的高4位字节设置位0。造成这个例外的原因是x86-64采用的惯例，即任何为寄存器生成32位值的指令都会把该寄存器的高位部分置成0。 --p123
* 常规的movq指令只能以表示为32位补码数字的立即数作为源操作数，然后把这个值符号扩展到64位的值，放到目的位置。movabsq指令能够以任意64位立即数值作为源操作数，并且只能以寄存器作为目的地。 --p123
* 练习题3.2 x86-64中的内存引用总是用四字长寄存器给出，例如%rax，哪怕操作数只是一个字节、一个字或是一个双字。 --p226
* 首先，我们看到C语言中所谓的“指针”其实就是地址。间接引用指针就是将该指针放在一个寄存器中，然后在内存引用中使用这个寄存器。其次，像x这样的局部变量通常是保存在寄存器中，而不是内存中。访问寄存器比访问内存要快得多。 --p125
* 练习题3.4 当执行强制类型转换既涉及大小变化又涉及C语言中符号变化时，操作应该先改变大小(2.2.6节)
    * 2.2.6 
        * 无符号数的**零扩展（zero extension）**：要将一个无符号数转换为一个更大的数据类型，我们只要简单地在表示开头添加0。
        * 补码数的符号扩展：要将一个补码数字转换为一个更大的数据类型，可以执行一个**符号扩展（sign extension）**，在表示中添加最高有效位的值。
### 3.4.4
* 栈可以实现为一个数组，总是从数组的一端插入和删除元素。这一端被称为**栈顶**。栈向下增长，这样一来，栈顶元素的地址是所有栈中元素地址中最低的。（根据惯例，我们的栈是倒过来画的，栈“顶”在图的底部。）栈指针%rsp保存着栈顶元素的地址。 --p127
* tips:栈寄存器%rsp，其实存放的就是栈顶的地址。 --p128
* 图3-9 牢记 --p128
# 2.5
* **加载有效地址(load effective address)**指令leaq实际上是movq指令的变形。它的指令形式是从内存读数据到寄存器，但实际上它根本就没有引用内存。它的第一个操作数看上去是一个内存引用，但该指令并不是从指定的位置读入数据，而是将有效地址写入到目的操作数。这条指令可以为后面的内存引用产生指针。另外，它还可以简洁地描述普通的算术操作。
* 只有leaq没有其他大小的变种，如ADD由四条加法指令组成：addb、addw、addl和addq
### 3.5.2 一元和二元操作
* 指令incq(%rsp)会使栈顶的**8字节元素加1**。C语言中（++、--操作）。
* 二元操作，第二个操作数即是源又是目的。C语言中的赋值运算符，例如x-=y。例如，指令subq %rax, %rdx使寄存器%rdx的值减去%rax中的值。（将指令解读成“从%rdx中减去%rax”会有所帮助。）注意，当第二个操作数为内存地址时，处理器必须从内存读出值，执行操作，再把结果写回内存。
### 3.6.6 用条件传送来实现条件分支
* 条件传送指令更符合现代处理器的性能特性。--p145
* 为了理解为什么基于条件数据传送的代码会比基于条件控制转移的代码（如图3-16中那样）性能要好，我们必须了解一些关于现代处理器如何运行的知识。正如我们将在第4章和第5章中看到，处理器通过使用**流水线(pipelinging)**来获得高性能，在流水线中，一条指令的处理要经过一系列的阶段，每个阶段执行所需操作的一小部分（例如，从内存取指令、确定指令类型、从内存读数据、执行算术运算、向内存写数据，以及更新程序计数器）。这种方法通过重叠连续指令的步骤来获得高性能，例如，在取一条指令的同时，执行它前面一条指令的算术运算。要做到这一点，要求能够事先确定要执行的指令序列，这样才能保持流水线中充满了待执行的指令。当机器遇到条件跳转（也称为“分支”）时，只有当分支条件求值完成之后，才能决定分支往哪走。处理器采用非常精密的**分支预测逻辑**来猜测每条跳转指令是否会执行。只要它的猜测还比较可靠（现代微处理器设计试图达到90%以上的成功率），指令流水线中就会充满着指令。另一方面，错误预测一个跳转，要求处理器丢掉它为该跳转指令后所有指令已做的工作，然后再开始用从正确位置处起始的指令去填充流水线。正如我们会看到的，这样一个错误预测会招致很严重的惩罚，浪费大约15~30个时钟周期，导致程序性能严重下降。 --p146

# 3.7 过程
当x86-64过程需要的存储空间超出寄存器能存放的大小时，就会在栈上分配空间。这个部分称为过程的**栈帧(stack frame)**。通过的栈帧结构（栈用来传递参数、存储返回信息、保存寄存器，以及局部存储。省略了不必要的部分）。当前正在执行的过程的帧总是在栈顶。通用寄存器，过程P可以传递最多6个整数值（也就是指针和整数），但是如果q需要更多的参数，P可以在调用Q之前在自己的栈帧里存储好这些参数。  
为了提高空间和时间效率，x86-64过程只分配自己所需要的栈帧部分。例如，许多过程有6个或者更少的参数，那么所有的参数都可以通过寄存器传递。因此，图3-25中画出的某些栈帧部分可以省略。实际上，许多函数甚至根本不需要栈帧。**当所有的局部变量都可以保存在寄存器中，而且该函数不会调用任何其他函数（有时称之为叶子过程，此时把过程调用看做树结构）时**，就可以这样处理。例如，到目前为止我们仔细审视过的所有函数都不需要栈帧。--p165d
如果一个函数有大于6个整型参数，超出6个的部分就要通过栈来传递。假设过程P调用过程Q，有n个整型参数，且n>6。那么P的代码分配的栈帧必须要能容纳7到n号参数的存储空间，如图3-25所示。要把参数1~6复制到对应的寄存器，把参数7~n放到栈上，而参数7位于栈顶。通过栈传递参数时，**所有的数据大小都向8的倍数对齐**。参数到位以后，程序就可以执行call指令将控制转移到过程Q了。过程Q可以通过寄存器访问参数，有必要的话可以通过栈访问。相应地，如果Q也调用了某个超过6个参数的函数，它也需要在自己的栈帧中为超出6个部分的参数分配空间，如图3-25中标号为“参数构造区”的区域所示。--p169

### 3.7.4 栈上的局部变量
到目前为止我么看到的大多数过程示例都不需要超出寄存器大小的本地存储区域。不过有些时候，局部数据必须存放在内存中，常见的情况包括：
* 寄存器不足够存放所有的本地数据
* 对一个局部变量使用地址运算符'&'，因此必须能够为它产生一个地址
* 某些局部变量是数组或结构，因此必须能够通过数组或结构引用被访问到。在描述数组和结构分配时，我们会讨论这个问题。
**用leaq指令生成到这些位置的指针。** 当调用过程proc时，程序会开始执行图3-29中的代码。如图3-30所示，参数7和8现在位于相对于栈指针偏移量为8和16的地方，因为返回地址这时已经被压入栈中了。--p172

### 3.7.5 寄存器中的局部存储空间
根据惯例，寄存器%rbx、%rbp和%r12~%r15被划分为**被调用者保存寄存器**。当过程P调用过程Q时，Q必须保存这些寄存器的值，保证它们的值在Q返回到P时与Q调用时是一样的。过程Q保存一个寄存器的值不变，要么就是根本不去改变它，要么就是把原始值压入栈中，改变寄存器的值，然后在返回前从栈中弹出旧值。压入寄存器的值会在栈帧中创建标号为“保存的寄存器”的一部分，如图3-25中所示。有了这条惯例，P的代码就能安全地把值存在被调用者保存寄存器中（当然，要先把之前的值保存到栈上），调用Q，然后继续使用寄存器中的值，不用担心值被破坏。  
所有其他的寄存器，除了栈指针%rsp，都分类为**调用者保存寄存器**。这就意味着任何函数都能修改它们。可以这样来理解“调用者保存”这个名字：过程P在某个此类寄存器中有局部数据，然后调用过程Q。因为Q可以随意修改这个寄存器，所以在调用之前首先保存好这个数据是P(调用者)的责任。